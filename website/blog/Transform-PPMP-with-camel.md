---
title: "PPMP Use Cases: Simple Transformation with Apache Camel"
date: 2018-02-11 00:00:00
tags: "use cases"
---
The Production Performance Management Protocol (PPMP) is a simple structure to send out machine data. Unide, as its hosting project, is supposed to provide exemplary implementations. 

We have already published [a REST server](https://github.com/eclipse/unide/tree/master/servers/rest), [java-](https://github.com/eclipse/unide.java) and [python-](https://github.com/eclipse/unide.python) bindings and an [html5-client](https://github.com/eclipse/unide/tree/master/clients/binsa). But how are these implementations used in real life?

# The Challenge
<div class="card figure">
	<div class="card-image">
		<figure class="image">
			<img alt="Welding robots" title="BMW plant, spot welding" src="/unide/images/blog/Transform-PPMP-with-camel-welding.jpg"></img>
		</figure>
	</div>
	<div class="card-content">
		BMW plant in Leipzig, Germany: Spot welding <a href="https://creativecommons.org/licenses/by-sa/2.0/de/deed.en">(CC BY-SA 2.0 DE)</a>
	</div>
</div>

In the automotive industry, [welding spots](https://en.wikipedia.org/wiki/Spot_welding) are crucial for the quality of a car and the security of the passenger. In modern production lines, hundreds of welding spots have to be precisely set in a single shift. In order to reduce product rework, scrap, destructable tests and machine downtime, the quality should be monitored consistently. That's what special welding controller in machines do. Unfortunately, this data is often only used locally, for a short period of time and in proprietary formats. Just enough to determine the immediate process outcome. In that case, further opportunities of analysing the information are not taken. With the continous increase in complexity, price and time pressure, the demand for further processing and optimization grows. The data could be used to prevent or even predict maintenance or just store the data in long time archives in case of legal disputes.

One prerequisite for such connectivity is the hardware and its connectivity. Older generations of welding controllers can only be accessed with proprietary stacks (like the [PSI 6000](https://www.boschrexroth.com/en/xc/products/product-groups/welding-technology/controllers-with-power-section/mf-system-psi6000/index)) whereas newer generations (like the [PRC 7000](https://www.boschrexroth.com/en/xc/company/press/index2-29696) are much more flexible in terms of networking and communication. In general, there are two aspects that make up the communication: the transport protocol and the structure of the payload. This is similar to our daily life: if you want to chat with your friends, you need to use the same messenger or communication technology (phone, email) and you need speak the same language (english, german etc.).

In the following sections, lets assume we need to transform the transport protocol as well as the payload. The data is generated by a welding controller and should be passed to [the unide REST server](https://unide.eclipse.org) for persisting it in a dedicated timeseries database.

# The Approach
We want to find a way to receive the data, transform it into PPMP and store it to a database with our [REST Server](https://unide.eclipse.org).

First, we need to understand which interfaces the controller has, which communication protocol is used, and how the payload would be interpreted. In the case of the PRC7000, it was configured to publish the quality data to a [mqtt](https://de.wikipedia.org/wiki/MQTT) message broker (here: [Eclipse mosquitto](https://mosquitto.org/)). We don't have an extensive documentation of the payload, but we can look at samples of it (some Curve data shortened at the end):
```json
{
  "Name": "WeldLog/UIR Testrack 24/",
  "WeldTimer": "UIR Testrack 24",
  "TimeStamp": "2018-01-17T10:41:00.0008436+01:00",
  "OutputFormat": "JSON",
  "Message": {
    "WeldLog": {
      "protRecord_ID": 734827,
      "dateTime": "2018-01-15T16:52:32.09",
      "timerName": "UIR Testrack 24",
      "progNo": 0,
      "spotName": "",
      "wear": 8312480,
      "wearPerCent": 0,
      "monitorState": 0,
      "regulationState": 0,
      "measureState": 0,
      "powerState": 0,
      "sequenceState": 0,
      "sequenceStateAdd": 0,
      "sequenceRepeat": 0,
      "monitorMode": 1,
      "iDemandStd": 3,
      "ilsts": 13.14,
      "regulationStd": 0,
      "iDemand1": 3,
      "iActual1": 0,
      "regulation1": 4,
      "iDemand2": 3,
      "iActual2": 13.16,
      "regulation2": 4,
      "iDemand3": 3,
      "iActual3": 0,
      "regulation3": 4,
      "phaStd": 24.96,
      "pha1": 0,
      "pha2": 24.64,
      "pha3": 0,
      "t_iDemandStd": 0,
      "tActualStd": 878,
      "partIdentString": "",
      "tipDressCounter": 0,
      "electrodeNo": 0,
      "sgForceSetPoint": null,
      "sgSheetThicknessSetPoint": null,
      "sgSagGpSetPoint": null,
      "sgSpotWithSg": null,
      "sgMotorCurrent": null,
      "sgMotorTemp": null,
      "sgForce": null,
      "sgSheetThickness": null,
      "sgSagGp": null,
      "sgSagGc": null,
      "regUsrUspJunction": 0,
      "regUsrUspMax": 0,
      "regSpotDiaActual": 0,
      "regSpotDiaMinDemand": 0,
      "regSplashTime": 0,
      "nuggetDiameter": 0,
      "usp": 0,
      "normingTime": 0,
      "regulationStartTime": 0,
      "returnToConstantCurrent": 0,
      "declineUsp": 0,
      "offsetUsp": 0,
      "currentFactor": 0,
      "triggerTime": 0,
      "xqrMeasuringActive": 0,
      "xqrRegulationActive": 0,
      "xqrMonitoringActive": 0,
      "xqrWeldTimeProlongationActive": 0,
      "voltageActualValue": 0.03,
      "voltageRefValue": 0.03,
      "currentActualValue": 13.17,
      "currentReferenceValue": 13.95,
      "weldTimeActualValue": 876,
      "weldTimeRefValue": 760,
      "energyActualValue": 395.1261,
      "energyRefValue": 342,
      "powerActualValue": 395.133,
      "powerRefValue": 449.35,
      "resistanceActualValue": 2,
      "resistanceRefValue": 2,
      "pulseWidthActualValue": 25.02,
      "pulseWidthRefValue": 26.19,
      "stabilisationFactorActValue": 55,
      "stabilisationFactorRefValue": 100,
      "thresholdStabilisationFactor": 0,
      "wldEffectStabilisationFactor": 100,
      "uipActualValue": 126,
      "uipRefValue": 100,
      "uirExpulsionTime": 0,
      "uirMeasuringActive": 1,
      "uirRegulationActive": 1,
      "uirMonitoringActive": 0,
      "uirWeldTimeProlongationActive": 1,
      "uirQStoppRefCntValue": 9,
      "uirQStoppActCntValue": 0,
      "uirUipUpperTol": 100,
      "uirUipLowerTol": 100,
      "uirUipCondTol": 100,
      "uirPsfLowerTol": 100,
      "uirPsfCondTol": 100,
      "weldSpotCustDataP16_1": null,
      "weldSpotCustDataP16_2": null,
      "weldSpotCustDataP16_3": null,
      "weldSpotCustDataP16_4": null,
      "weldSpotCustDataP16_5": null,
      "weldSpotCustDataP32_6": null,
      "weldSpotCustDataP16_7": null,
      "weldSpotCustDataP16_8": null,
      "weldSpotCustDataP16_9": null,
      "weldSpotCustDataP16_10": null,
      "weldSpotCustDataP16_11": null,
      "weldSpotCustDataP32_12": null,
      "weldSpotCustDataP16_13": null,
      "weldSpotCustDataP16_14": null,
      "weldSpotCustDataP16_15": null,
      "weldSpotCustDataP16_16": null,
      "weldSpotCustDataP16_17": null,
      "weldSpotCustDataP32_18": null,
      "uipMonCondUpperTol": 100,
      "fqfActualValue": 0,
      "fqfRefValue": 100,
      "fqfMonUpperTol": 100,
      "fqfMonLowerTol": 100,
      "fqfMonCondUpperTol": 100,
      "fqfMonCondLowerTol": 100,
      "fqfMeasuringActive": 0,
      "xqrModeOff": 0,
      "reweldActive": 0,
      "weldspotRefIdent": "UIR_PART",
      "sg_Torque_Gp": null,
      "sg_Force_Corr": null,
      "sg_Weldspot_Geo_Wear": null,
      "sg_Wear_Length": null,
      "sg_Beam_UpArching": null,
      "CurrentCurve": [
        11621,
        15434,
        ...
      ],
      "VoltageCurve": [
        39,
        29,
        ...
      ],
      "ForceCurve": [
        49,
        49,
        ...
      ]
    }
  }
}
```
That's already very detailed, but it's unclear which device / welding spot the data comes from and what the timimg of the curves was. Let's get some more structure in with PPMP!

In PPMP, we have the option to differentiate between discrete manufacturing data (MES - part produced) by using the [measurement-message](/unide/specification/measurement-message) and detailed process data by using the [process-message](https://www.eclipse.org/unide/specification/process-message). In the welding payload, that's all combined in one message. So we also want to split this payload into two.

## Introducing Apache Camel
<div class="card figure is-pulled-left">
	<div class="card-image">
		<figure class="image">
			<img alt="Welding robots" title="BMW plant, spot welding" src="/unide/images/blog/Transform-PPMP-with-camel-camel.png"></img>
		</figure>
	</div>
	<div class="card-content">
		Apache Camel, <a href="https://www.apache.org/licenses/LICENSE-2.0">(Apache&nbsp;License&nbsp;2.0)</a>
	</div>
</div>

[Apache Camel](https://en.wikipedia.org/wiki/Apache_Camel) is a java-based Open Source framework, that can transform and route data. It supports most of the [Enterprise Integration Patterns](https://en.wikipedia.org/wiki/Enterprise_Integration_Patterns) and hundreds(!) of [connectors / components](http://camel.apache.org/components.html). Think of it as an extensive transformation and workflow automation engine. In fact, it's so powerful and versatile, that it unfortunately doesn't come with a visual user interface or a plug-and-play installer. Luckily, for everyone who doesn't happen to be a java expert, there's also an xml configuration (via [spring xml](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html)). And that's mostly all we need!

## Transforming the Communication Protocol
We will use Spring XML to configure Apache Camel. The workflow in Camel are called ``<routes>``. So let's create a route that transforms our mqtt to REST protocol:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:camel="http://camel.apache.org/schema/spring"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/util
	http://www.springframework.org/schema/util/spring-util.xsd 
	http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://camel.apache.org/schema/spring
    http://camel.apache.org/schema/spring/camel-spring.xsd">
	<camelContext xmlns="http://camel.apache.org/schema/spring">
		<route>
			<from
				uri="mqtt://prc7000?host=tcp://192.168.123.135:1883&amp;subscribeTopicName=PRC7000//PROCESS/PPMP/PROCESS" />
			<to
				uri="jetty:http://unide.eclipse.org:8080/rest/v2/measurement?bridgeEndpoint=true&amp;throwExceptionOnFailure=true"/>
		</route>
	</camelContext>
</beans>
```
That's it! A ``<route>`` that reads``<from>`` mqtt and forwards ``<to>`` http. Not so difficult, is it? We could use many of the other [connectors / components](http://camel.apache.org/components.html) in the example above as well to transform from/to different protocols.

But wait! The welding payload above was not PPMP. So we also need to normalize the payload.

## Normalizing the Payload

Now that we can easily convert protocols, let's address the structure of the payload. Overall, we want to have a workflow that looks as described in the diagram below:
<div class="card figure">
	<div class="card-image">
		<figure class="image">
			<img alt="data workflow" title="data workflow" src="/unide/images/blog/Transform-PPMP-with-camel-1.svg"></img>
		</figure>
	</div>
	<div class="card-content">
		BMW plant in Leipzig, Germany: Spot welding <a href="https://creativecommons.org/licenses/by-sa/2.0/de/deed.en">(CC BY-SA 2.0 DE)</a>
	</div>
</div>

The extra steps here are:
1. transform the PRC7000 JSON String payload to a java object
2. transform the PRC7000 java object to two PPMP-java objects ([measurement-message](/unide/specification/measurement-message) and [process-message](https://www.eclipse.org/unide/specification/process-message))
3. split up the two PPMP objects
4. route the objects individually
5. transform each PPMP object back to a String

### Create the PRC7000 Java Object
Luckily, there are helper for transforming json (or xml) to plain old java objects (POJOs). We are using [jsonschema2pojo](http://www.jsonschema2pojo.org/) to convert the above json sample to POJOs with Jackson 2.x annotation. I name the resulting data type class ``PRC7000DataType`` and organize it in the package ``org.eclipse.iot.unide.integrators``. Based on the given testdata, jsonschema2pojo cannot fully deduct all attribute types correctly. In order to allow floating point values, we would rename all ``Integer`` and ``Object`` types to ``Number`` in the WeldLog.java file. Also in the same file, we would change the type of the ``dateTime`` field from String to ``LocalDateTime`` to be more accurate:
```java
...
@JsonProperty("dateTime")
@JsonSerialize(using = LocalDateTimeSerializer.class)
@JsonDeserialize(using = LocalDateTimeDeserializer.class)
private LocalDateTime dateTime;
...
```
For that, we also need to include the respective imports
```java
...
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
...
```
and adjust the getter (``getDateTime()``), setter (``setDateTime()``) and the type in the constructor (``public WeldLog(...)``) accordingly.

Camel will be able to transform ("*unmarshal*") this datatype from a string to a POJO after adding the definition to the above Spring XML:
```xml
...
<camelContext xmlns="http://camel.apache.org/schema/spring">
	<dataFormats>
		<json id="prc7000" library="Jackson"
			unmarshalTypeName="org.eclipse.iot.unide.integrators.PRC7000DataType" />
	</dataFormats>
	...
</camelContext>
```

### Use unide.java binding for PPMP Java Objects
For eventually transforming the PPMP objects back to String ("*marshal*"), we can make use of the [unide PPMP java binding](https://github.com/eclipse/unide.java). Just adjust the dataFormats section of the Spring XML so that it reads:
```xml
...
<camelContext xmlns="http://camel.apache.org/schema/spring">
	<dataFormats>
		<json id="prc7000" library="Jackson"
			unmarshalTypeName="org.eclipse.iot.unide.integrators.PRC7000DataType" />
		<json id="ppmpMeasurementMessage" library="Jackson"
			unmarshalTypeName="org.eclipse.iot.unide.ppmp.measurements.MeasurementsWrapper"
			moduleClassNames="com.fasterxml.jackson.datatype.jsr310.JavaTimeModule"
			disableFeatures="WRITE_DATES_AS_TIMESTAMPS" 
			include="NON_NULL"/>
		<json id="ppmpProcessMessage" library="Jackson"
			unmarshalTypeName="org.eclipse.iot.unide.ppmp.process.ProcessWrapper"
			moduleClassNames="com.fasterxml.jackson.datatype.jsr310.JavaTimeModule"
			disableFeatures="WRITE_DATES_AS_TIMESTAMPS"
			include="NON_NULL" />
	</dataFormats>
	...
</camelContext>
```

### Create the Workflow
In order to better structure dataflow, we use multiple ``<route>``-s: one for retrieving the data and two more after the split of the payload. They are connected via the virtual camel protocol "*direct*". In the following Spring XML, you can also find some ``<log>`` points and additional steps to set http header (``<setHeader>``) for posting to the unide server:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:camel="http://camel.apache.org/schema/spring"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/util
	http://www.springframework.org/schema/util/spring-util.xsd 
	http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://camel.apache.org/schema/spring
    http://camel.apache.org/schema/spring/camel-spring.xsd">

	<bean id="prc7000-to-ppmp" class="org.eclipse.iot.unide.integrators.PRC7000"></bean>

	<camelContext xmlns="http://camel.apache.org/schema/spring">
		<dataFormats>
			<json id="prc7000" library="Jackson"
				unmarshalTypeName="org.eclipse.iot.unide.integrators.PRC7000DataType" />
			<json id="ppmpMeasurementMessage" library="Jackson"
				unmarshalTypeName="org.eclipse.iot.unide.ppmp.measurements.MeasurementsWrapper"
				moduleClassNames="com.fasterxml.jackson.datatype.jsr310.JavaTimeModule"
				disableFeatures="WRITE_DATES_AS_TIMESTAMPS" include="NON_NULL" />
			<json id="ppmpProcessMessage" library="Jackson"
				unmarshalTypeName="org.eclipse.iot.unide.ppmp.process.ProcessWrapper"
				moduleClassNames="com.fasterxml.jackson.datatype.jsr310.JavaTimeModule"
				disableFeatures="WRITE_DATES_AS_TIMESTAMPS" include="NON_NULL" />
		</dataFormats>

		<route autoStartup="true">
			<from
				uri="mqtt://prc7000?host=tcp://192.168.123.135:1883&amp;subscribeTopicName=PRC7000//PROCESS/PPMP/PROCESS" />
			<unmarshal ref="prc7000" />

			<bean ref="prc7000-to-ppmp" />

			<setHeader headerName="Content-Type">
				<constant>application/json; charset=utf-8</constant>
			</setHeader>
			<setHeader headerName="CamelHttpMethod">
				<constant>POST</constant>
			</setHeader>
			<multicast>
				<to uri="direct:measurement" />
				<to uri="direct:process" />
			</multicast>
			<log message="done" />
			<setBody>
				<simple>{"result": true }</simple>
			</setBody>
		</route>

		<route>
			<from uri="direct:measurement" />
			<setBody>
				<simple>${body[0]}</simple>
			</setBody>
			<log message="deviceId measurement: ${body.device.deviceID}" />

			<marshal ref="ppmpMeasurementMessage" />

			<log message="sending measurement" />
			<setHeader headerName="Content-Length">
				<simple>body.length</simple>
			</setHeader>
			<to
				uri="jetty:http://unide.eclipse.org:8080/rest/v2/measurement?bridgeEndpoint=true&amp;throwExceptionOnFailure=true" />
			<log message="measurement sent" />
		</route>

		<route>
			<from uri="direct:process" />
			<setBody>
				<simple>${body[1]}</simple>
			</setBody>
			<log message="deviceId process: ${body.device.deviceID}" />

			<marshal ref="ppmpProcessMessage" />

			<log message="sending process" />
			<setHeader headerName="Content-Length">
				<simple>body.length</simple>
			</setHeader>
			<to
				uri="jetty:http://unide.eclipse.org:8080/rest/v2/process?bridgeEndpoint=true&amp;throwExceptionOnFailure=true" />
			<log message="process sent" />
		</route>
	</camelContext>
</beans>
```

You might have noticed that we have not yet discussed one important item in this workflow: how do we actually transform the payload from one format to another?

###  Transforming from PRC7000 POJO to PPMP POJOs
One thing that we'll hardwire as java code is the transformation from the source to the target structure. The same functionality could be achieved with scripting components (e.g. [groovy](http://camel.apache.org/groovy.html), but that would be less powerful and worse performance. Since we don't expect the format to change but mostly the workflow or endpoints, implementing a java bean is not too much effort. Here's how:
Apache Camel offers a ``Processor`` interface that can be used to override the ``process()`` function. This function receives the complete message (``exchange``) and can modify it in any way. Since we have created the PRC7000 Java Object already and want to produce PPMP java objects, the logic is mostly about creating the child objects and wiring the suitable getter to corresponding setter.

```java
package org.eclipse.iot.unide.integrators;

import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.eclipse.iot.unide.ppmp.commons.Device;
import org.eclipse.iot.unide.ppmp.commons.MetaData;
import org.eclipse.iot.unide.ppmp.measurements.MeasurementsWrapper;
import org.eclipse.iot.unide.ppmp.process.Process;
import org.eclipse.iot.unide.ppmp.process.ProcessWrapper;

import com.fasterxml.jackson.core.JsonProcessingException;

public class PRC7000 implements Processor {

	public PRC7000() {}

	private org.eclipse.iot.unide.ppmp.measurements.SeriesMap addMeasurementPoint(
			org.eclipse.iot.unide.ppmp.measurements.SeriesMap map, String name, Number value) {
		if (value != null) {
			map.setSeriesValue(name, Arrays.asList(value));
		}
		return map;
	}

	@Override
	public void process(Exchange exchange) throws JsonProcessingException, Exception {
		Message msg = exchange.getIn();
		PRC7000DataType doc = msg.getBody(PRC7000DataType.class);

		Object []bundle = new Object[2];
		bundle[0]		= transformMeasurement(doc);
		bundle[1]		= transformProcess(doc);
		msg.setBody(bundle);
		exchange.setOut(msg);
	}

	private void setSpotName(Device device, WeldLog wl) {
		String spotName = wl.getSpotName();
		if (spotName != null && spotName.length() > 0) {
			MetaData md = new MetaData();
			md.setMetaDataValue("spotName", wl.getSpotName());
			device.setMetaData(md);
		}
	}

	private ProcessWrapper transformProcess(PRC7000DataType doc) {
		ProcessWrapper wrapper = new ProcessWrapper();
		WeldLog wl = doc.getMessage().getWeldLog();
		OffsetDateTime odt = OffsetDateTime.of(wl.getDateTime(), ZoneOffset.UTC);

		// device
		Device device = new Device();
		device.setDeviceID(doc.getMessage().getWeldLog().getTimerName());
		setSpotName(device, wl);
		wrapper.setDevice(device);

		// part
		String partId = wl.getPartIdentString();
		if (partId != null && partId.length() > 0) {
			org.eclipse.iot.unide.ppmp.process.Part part = new org.eclipse.iot.unide.ppmp.process.Part();
			part.setPartID(partId);
			wrapper.setPart(part);
		}

		// process
		Process process = new Process();
		process.setTimestamp(odt);
		process.setExternalProcessId(String.valueOf(wl.getProtRecordID()));
		wrapper.setProcess(process);

		// measurements
		List<org.eclipse.iot.unide.ppmp.process.Measurements> measurements = new LinkedList<org.eclipse.iot.unide.ppmp.process.Measurements>();
		org.eclipse.iot.unide.ppmp.process.Measurements measurement = new org.eclipse.iot.unide.ppmp.process.Measurements();
		
		measurement.setTimestamp(odt);

		//values
		org.eclipse.iot.unide.ppmp.process.SeriesMap seriesMap = new org.eclipse.iot.unide.ppmp.process.SeriesMap();
		seriesMap.setSeriesValue("curentCurve", wl.getCurrentCurve());
		seriesMap.setSeriesValue("voltageCurve", wl.getVoltageCurve());
		seriesMap.setSeriesValue("forceCurve", wl.getForceCurve());
		
		measurement.setSeriesMap(seriesMap);
		measurements.add(measurement);
		wrapper.setMeasurements(measurements);
		
		return wrapper;
	}

	private MeasurementsWrapper transformMeasurement(PRC7000DataType doc) {
		MeasurementsWrapper wrapper = new MeasurementsWrapper();
		WeldLog wl = doc.getMessage().getWeldLog();

		// device
		Device device = new Device();
		device.setDeviceID(doc.getMessage().getWeldLog().getTimerName());
		setSpotName(device, wl);
		wrapper.setDevice(device);

		// part
		String partId = wl.getPartIdentString();
		if (partId != null && partId.length() > 0) {
			org.eclipse.iot.unide.ppmp.measurements.Part part = new org.eclipse.iot.unide.ppmp.measurements.Part();
			part.setPartID(partId);
			wrapper.setPart(part);
		}

		// measurements
		List<org.eclipse.iot.unide.ppmp.measurements.Measurements> measurements = new LinkedList<org.eclipse.iot.unide.ppmp.measurements.Measurements>();
		org.eclipse.iot.unide.ppmp.measurements.Measurements measurement = new org.eclipse.iot.unide.ppmp.measurements.Measurements();

		measurement.setTimestamp(OffsetDateTime.of(wl.getDateTime(), ZoneOffset.UTC));

		// values
		org.eclipse.iot.unide.ppmp.measurements.SeriesMap seriesMap = new org.eclipse.iot.unide.ppmp.measurements.SeriesMap();
		seriesMap.setSeriesValue("$_time", Arrays.asList(0));

		addMeasurementPoint(seriesMap, "wear", wl.getWear());
		addMeasurementPoint(seriesMap, "wearPerCent", wl.getWearPerCent());
		addMeasurementPoint(seriesMap, "monitorState", wl.getMonitorState());
		addMeasurementPoint(seriesMap, "regulationState", wl.getRegulationState());
		addMeasurementPoint(seriesMap, "measureState", wl.getMeasureState());
		addMeasurementPoint(seriesMap, "powerState", wl.getPowerState());
		addMeasurementPoint(seriesMap, "sequenceState", wl.getSequenceState());
		addMeasurementPoint(seriesMap, "sequenceStateAdd", wl.getSequenceStateAdd());
		addMeasurementPoint(seriesMap, "sequenceRepeat", wl.getSequenceRepeat());
		addMeasurementPoint(seriesMap, "monitorMode", wl.getMonitorMode());
		addMeasurementPoint(seriesMap, "iDemandStd", wl.getIDemandStd());
		addMeasurementPoint(seriesMap, "ilsts", wl.getIlsts());
		addMeasurementPoint(seriesMap, "regulationStd", wl.getRegulationStd());
		addMeasurementPoint(seriesMap, "iDemand1", wl.getIDemand1());
		addMeasurementPoint(seriesMap, "iActual1", wl.getIActual1());
		addMeasurementPoint(seriesMap, "regulation1", wl.getRegulation1());
		addMeasurementPoint(seriesMap, "iDemand2", wl.getIDemand2());
		addMeasurementPoint(seriesMap, "iActual2", wl.getIActual2());
		addMeasurementPoint(seriesMap, "regulation2", wl.getRegulation2());
		addMeasurementPoint(seriesMap, "iDemand3", wl.getIDemand3());
		addMeasurementPoint(seriesMap, "iActual3", wl.getIActual3());
		addMeasurementPoint(seriesMap, "regulation3", wl.getRegulation3());
		addMeasurementPoint(seriesMap, "phaStd", wl.getPhaStd());
		addMeasurementPoint(seriesMap, "pha1", wl.getPha1());
		addMeasurementPoint(seriesMap, "pha2", wl.getPha2());
		addMeasurementPoint(seriesMap, "pha3", wl.getPha3());
		addMeasurementPoint(seriesMap, "t_iDemandStd", wl.getIDemandStd());
		addMeasurementPoint(seriesMap, "tActualStd", wl.getTActualStd());
		// addMeasurementPoint(seriesMap, "partIdentString",
		// wl.getPartIdentString());
		addMeasurementPoint(seriesMap, "tipDressCounter", wl.getTipDressCounter());
		addMeasurementPoint(seriesMap, "electrodeNo", wl.getElectrodeNo());
		addMeasurementPoint(seriesMap, "sgForceSetPoint", wl.getSgForceSetPoint());
		addMeasurementPoint(seriesMap, "sgSheetThicknessSetPoint", wl.getSgSheetThicknessSetPoint());
		addMeasurementPoint(seriesMap, "sgSagGpSetPoint", wl.getSgSagGpSetPoint());
		addMeasurementPoint(seriesMap, "sgSpotWithSg", wl.getSgSpotWithSg());
		addMeasurementPoint(seriesMap, "sgMotorCurrent", wl.getSgMotorCurrent());
		addMeasurementPoint(seriesMap, "sgMotorTemp", wl.getSgMotorTemp());
		addMeasurementPoint(seriesMap, "sgForce", wl.getSgForce());
		addMeasurementPoint(seriesMap, "sgSheetThickness", wl.getSgSheetThickness());
		addMeasurementPoint(seriesMap, "sgSagGp", wl.getSgSagGp());
		addMeasurementPoint(seriesMap, "sgSagGc", wl.getSgSagGc());
		addMeasurementPoint(seriesMap, "regUsrUspJunction", wl.getRegUsrUspJunction());
		addMeasurementPoint(seriesMap, "regUsrUspMax", wl.getRegUsrUspMax());
		addMeasurementPoint(seriesMap, "regSpotDiaActual", wl.getRegSpotDiaActual());
		addMeasurementPoint(seriesMap, "regSpotDiaMinDemand", wl.getRegSpotDiaMinDemand());
		addMeasurementPoint(seriesMap, "regSplashTime", wl.getRegSplashTime());
		addMeasurementPoint(seriesMap, "nuggetDiameter", wl.getNuggetDiameter());
		addMeasurementPoint(seriesMap, "usp", wl.getUsp());
		addMeasurementPoint(seriesMap, "normingTime", wl.getNormingTime());
		addMeasurementPoint(seriesMap, "regulationStartTime", wl.getRegulationStartTime());
		addMeasurementPoint(seriesMap, "returnToConstantCurrent", wl.getReturnToConstantCurrent());
		addMeasurementPoint(seriesMap, "declineUsp", wl.getDeclineUsp());
		addMeasurementPoint(seriesMap, "offsetUsp", wl.getOffsetUsp());
		addMeasurementPoint(seriesMap, "currentFactor", wl.getCurrentFactor());
		addMeasurementPoint(seriesMap, "triggerTime", wl.getTriggerTime());
		addMeasurementPoint(seriesMap, "xqrMeasuringActive", wl.getXqrMeasuringActive());
		addMeasurementPoint(seriesMap, "xqrRegulationActive", wl.getXqrRegulationActive());
		addMeasurementPoint(seriesMap, "xqrMonitoringActive", wl.getXqrMonitoringActive());
		addMeasurementPoint(seriesMap, "xqrWeldTimeProlongationActive", wl.getXqrWeldTimeProlongationActive());
		addMeasurementPoint(seriesMap, "voltageActualValue", wl.getVoltageActualValue());
		addMeasurementPoint(seriesMap, "voltageRefValue", wl.getVoltageRefValue());
		addMeasurementPoint(seriesMap, "currentActualValue", wl.getCurrentActualValue());
		addMeasurementPoint(seriesMap, "currentReferenceValue", wl.getCurrentReferenceValue());
		addMeasurementPoint(seriesMap, "weldTimeActualValue", wl.getWeldTimeActualValue());
		addMeasurementPoint(seriesMap, "weldTimeRefValue", wl.getWeldTimeRefValue());
		addMeasurementPoint(seriesMap, "energyActualValue", wl.getEnergyActualValue());
		addMeasurementPoint(seriesMap, "energyRefValue", wl.getEnergyRefValue());
		addMeasurementPoint(seriesMap, "powerActualValue", wl.getPowerActualValue());
		addMeasurementPoint(seriesMap, "powerRefValue", wl.getPowerRefValue());
		addMeasurementPoint(seriesMap, "resistanceActualValue", wl.getResistanceActualValue());
		addMeasurementPoint(seriesMap, "resistanceRefValue", wl.getResistanceRefValue());
		addMeasurementPoint(seriesMap, "pulseWidthActualValue", wl.getPulseWidthActualValue());
		addMeasurementPoint(seriesMap, "pulseWidthRefValue", wl.getPulseWidthRefValue());
		addMeasurementPoint(seriesMap, "stabilisationFactorActValue", wl.getStabilisationFactorActValue());
		addMeasurementPoint(seriesMap, "stabilisationFactorRefValue", wl.getStabilisationFactorRefValue());
		addMeasurementPoint(seriesMap, "thresholdStabilisationFactor", wl.getThresholdStabilisationFactor());
		addMeasurementPoint(seriesMap, "wldEffectStabilisationFactor", wl.getWldEffectStabilisationFactor());
		addMeasurementPoint(seriesMap, "uipActualValue", wl.getUipActualValue());
		addMeasurementPoint(seriesMap, "uipRefValue", wl.getUipRefValue());
		addMeasurementPoint(seriesMap, "uirExpulsionTime", wl.getUirExpulsionTime());
		addMeasurementPoint(seriesMap, "uirMeasuringActive", wl.getUirMeasuringActive());
		addMeasurementPoint(seriesMap, "uirRegulationActive", wl.getUirRegulationActive());
		addMeasurementPoint(seriesMap, "uirMonitoringActive", wl.getUirMonitoringActive());
		addMeasurementPoint(seriesMap, "uirWeldTimeProlongationActive", wl.getUirWeldTimeProlongationActive());
		addMeasurementPoint(seriesMap, "uirQStoppRefCntValue", wl.getUirQStoppRefCntValue());
		addMeasurementPoint(seriesMap, "uirQStoppActCntValue", wl.getUirQStoppActCntValue());
		addMeasurementPoint(seriesMap, "uirUipUpperTol", wl.getUirUipUpperTol());
		addMeasurementPoint(seriesMap, "uirUipLowerTol", wl.getUirUipLowerTol());
		addMeasurementPoint(seriesMap, "uirUipCondTol", wl.getUirUipCondTol());
		addMeasurementPoint(seriesMap, "uirPsfLowerTol", wl.getUirPsfLowerTol());
		addMeasurementPoint(seriesMap, "uirPsfCondTol", wl.getUirPsfCondTol());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_1", wl.getWeldSpotCustDataP161());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_2", wl.getWeldSpotCustDataP162());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_3", wl.getWeldSpotCustDataP163());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_4", wl.getWeldSpotCustDataP164());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_5", wl.getWeldSpotCustDataP165());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP32_6", wl.getWeldSpotCustDataP326());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_7", wl.getWeldSpotCustDataP167());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_8", wl.getWeldSpotCustDataP168());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_9", wl.getWeldSpotCustDataP169());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_10", wl.getWeldSpotCustDataP1610());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_11", wl.getWeldSpotCustDataP1611());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP32_12", wl.getWeldSpotCustDataP3212());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_13", wl.getWeldSpotCustDataP1613());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_14", wl.getWeldSpotCustDataP1614());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_15", wl.getWeldSpotCustDataP1615());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_16", wl.getWeldSpotCustDataP1616());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP16_17", wl.getWeldSpotCustDataP1617());
		addMeasurementPoint(seriesMap, "weldSpotCustDataP32_18", wl.getWeldSpotCustDataP3218());
		addMeasurementPoint(seriesMap, "uipMonCondUpperTol", wl.getUipMonCondUpperTol());
		addMeasurementPoint(seriesMap, "fqfActualValue", wl.getFqfActualValue());
		addMeasurementPoint(seriesMap, "fqfRefValue", wl.getFqfRefValue());
		addMeasurementPoint(seriesMap, "fqfMonUpperTol", wl.getFqfMonUpperTol());
		addMeasurementPoint(seriesMap, "fqfMonLowerTol", wl.getFqfMonLowerTol());
		addMeasurementPoint(seriesMap, "fqfMonCondUpperTol", wl.getFqfMonCondUpperTol());
		addMeasurementPoint(seriesMap, "fqfMonCondLowerTol", wl.getFqfMonCondLowerTol());
		addMeasurementPoint(seriesMap, "fqfMeasuringActive", wl.getFqfMeasuringActive());
		addMeasurementPoint(seriesMap, "xqrModeOff", wl.getXqrModeOff());
		addMeasurementPoint(seriesMap, "reweldActive", wl.getReweldActive());
		// addMeasurementPoint(seriesMap, "weldspotRefIdent",
		// wl.getWeldspotRefIdent());
		addMeasurementPoint(seriesMap, "sg_Torque_Gp", wl.getSgTorqueGp());
		addMeasurementPoint(seriesMap, "sg_Force_Corr", wl.getSgForceCorr());
		addMeasurementPoint(seriesMap, "sg_Weldspot_Geo_Wear", wl.getSgWeldspotGeoWear());
		addMeasurementPoint(seriesMap, "sg_Wear_Length", wl.getSgWearLength());
		addMeasurementPoint(seriesMap, "sg_Beam_UpArching", wl.getSgBeamUpArching());

		measurement.setSeriesMap(seriesMap);
		measurements.add(measurement);
		wrapper.setMeasurements(measurements);

		return wrapper;
	}
}
```

# Summary
It takes a while to understand the involved software components. Yet, once the set up is running, it gets much easier to adapt it to another Use Case. And another. The pattern of wiring protocols and transforming the payload is very similar. The involved frameworks are powerful enough to support many Use Cases. This article is supposed to show that there are simple possibilities to transform transport protocols and payloads, so that you can focus on adressing functional challenges.
